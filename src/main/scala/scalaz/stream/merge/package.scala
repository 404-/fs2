package scalaz.stream


import scalaz._
import scalaz.concurrent.{Actor, Strategy, Task}
import scalaz.stream.Process._


package object merge {


  /**
   * Merges non-deterministically processes that are output of the `source` process.
   *
   * Merging stops when all processes generated by source have stopped, and all source process stopped as well.
   * Merging will also stop when resulting process terminated. In that case the cleanup of all `source`
   * processes is run, followed by cleanup of resulting process.
   *
   * When one of the source processes fails the mergeN process will fail with that reason.
   *
   * Merging is non-deterministic, but is fair in sense that every process is consulted, once it has `A` ready.
   * That means processes that are `faster` provide it's `A` more often than slower processes.
   *
   * Internally mergeN keeps small buffer that reads ahead up to `n` values of `A` where `n` equals to number
   * of active source streams. That does not mean that every `source` process is consulted in this read-ahead
   * cache, it just tries to be as much fair as possible when processes provide their `A` on almost the same speed.
   *
   */
  def mergeN[A](source: Process[Task, Process[Task, A]])(implicit S: Strategy): Process[Task, A] =
    nJoin(0, 0)(source)(S)

  /**
   * MergeN variant, that allows to specify maximum of open `source` processes.
   * If, the maxOpen is <= 0 it acts like standard mergeN, where the number of processes open is not limited.
   * However, when the maxOpen > 0, then at any time only `maxOpen` processes will be running at any time
   *
   * This allows for limiting the eventual concurrent processing of opened streams not only by supplied strategy,
   * but also by providing a `maxOpen` value.
   *
   *
   * @param maxOpen   Max number of open (running) processes at a time
   * @param source    source of processes to merge
   */
  def mergeN[A](maxOpen: Int)(source: Process[Task, Process[Task, A]])(implicit S: Strategy): Process[Task, A] =
    nJoin(maxOpen, maxOpen)(source)(S)


  /**
   * Non-deterministic join of streams. Streams are joined non deterministically.
   * Whenever one of the streams terminates with other exception than `End`
   * the whole join terminates with that reason and all
   * remaining input processes are terminated with that cause as well.
   *
   * If the resulting process terminates, all the merged processes terminates with supplied reason,
   * in case downstream terminates with `End` the upstream processes are terminated as well.
   *
   * @param maxOpen     maximum simultaneous processes that concurrently merge. If eq 0 no limit.
   * @param maxQueued   maximum number of queued `A` before merged processes will back-off. If eq 0 no limit.
   * @param source
   * @param S
   * @tparam A
   * @return
   */
  def nJoin[A](maxOpen: Int, maxQueued: Int)(source: Process[Task, Process[Task, A]])(implicit S: Strategy): Process[Task, A] = {
    sealed trait M
    case class Offer(p: Process[Task, A], next: Throwable => Process[Task, Process[Task, A]]) extends M
    case class FinishedSource(rsn: Throwable) extends M
    case class Finished(result: Throwable \/ Unit) extends M
    case class FinishedDown(rsn: Throwable, cb: (Throwable \/ Unit) => Unit) extends M


    suspend {
      val q = async.boundedQueue[A](maxQueued)(S)
      val done = async.signal[Boolean](S)

      //keep state of master source
      var state: Either3[Throwable, Throwable => Unit, Throwable => Process[Task, Process[Task, A]]] =
        Either3.middle3((_: Throwable) => ())

      //keep no of open processes
      var opened: Int = 0

      var actor: Actor[M] = null

      //evaluates next step of the source
      def nextStep(from: Process[Task, Process[Task, A]]) =
        Either3.middle3(
          from.runAsync({
            case -\/(rsn) =>
              actor ! FinishedSource(rsn)

            case \/-((processes, next)) =>
              actor ! Offer(processes.head, (rsn: Throwable) => rsn match {
                case End => emitAll(processes.tail) ++ next(End)
                case _   => next(rsn)
              })
          })
        )

      // fails the signal and queue with given reason
      def fail(rsn: Throwable): Unit = {
        state = Either3.left3(rsn)
        (for {
          _ <- q.fail(rsn)
          _ <- done.set(true)
          _ <- done.close
        } yield ()).runAsync(_ => ())
      }

      // initially sets signal and starts the source evaluation
      def start: Task[Unit] =
        done.set(false).map { _ => state = nextStep(source) }


      actor = Actor[M]({
        // next merged process is available
        // run it with chance to interrupt
        // and give chance to start next process if not bounded
        case Offer(p, next) =>
          opened = opened + 1
          if (opened < maxOpen) state = nextStep(Util.Try(next(End)))
          else state = Either3.right3(next)

          //runs the process with a chance to interrupt it using signal `done`
          //interrupt is done via setting the done to `true`
          done.discrete.wye(p)(wye.interrupt)
          .run.runAsync { res =>
            actor ! Finished(res)
          }

        //finished the `upstream` but still have some open processes to merging
        case FinishedSource(End) if opened > 0 =>
          state = Either3.left3(End)

        // finished upstream and no processes are running, terminate downstream
        case FinishedSource(rsn) =>
          fail(rsn)

        //merged process terminated. This always != End
        //as such terminate the join with given exception
        case Finished(-\/(rsn)) =>
          opened = opened - 1
          fail(state match {
            case Left3(End) => rsn
            case Left3(rsn0) if rsn0 != End => rsn0
            case Middle3(interrupt) => interrupt(Kill); rsn
            case Right3(next) => Util.Try(next(Kill)).run.runAsync(_ => ()); rsn
          })

        // One of the processes terminated w/o failure
        // Finish merge if the opened == 0 and upstream terminated
        // or give an opportunity to start next merged process if the maxOpen was hit
        case Finished(\/-(_)) =>
          opened = opened - 1
          state = state match {
            case Right3(next)
              if maxOpen <= 0 || opened < maxOpen => nextStep(Util.Try(next(End)))
            case Left3(rsn) if opened == 0        => fail(End); state
            case other                            => other
          }

        // `Downstream` of the merge terminated
        // Kill all upstream processes and eventually the source.
        case FinishedDown(rsn, cb) =>
          fail(state match {
            case Left3(_)           => rsn
            case Middle3(interrupt) => interrupt(Kill); rsn
            case Right3(next)       => rsn
          })

      })


      (eval_(start) fby q.dequeue)
      .onHalt(rsn => eval_(Task.async[Unit] { cb => actor ! FinishedDown(rsn, cb) }))
    }
  }

}
